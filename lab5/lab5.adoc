:imagesdir: Images
:figure-caption: Рисунок
[.text-center]
МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ +
Федеральное государственное автономное образовательное учреждение высшего образования +
«Южно-Уральский государственный университет» +
(национальный исследовательский университет) +
Высшая школа электроники и компьютерных наук +
Кафедра «Информационно-измерительная техника»

[.text-center]

Отчет по лабораторной работе №4

[.text-right]
Выполнили: +
студенты группы КЭ-415 +
Леонов В.А.
Платонов Д.В.


== Лабораторная работа №4
=== Задание
--
Написать программу, *которая моргает всеми 4 светодиодами*, но без использования GPIOA::ODR::ODR5::High::Set() и тому подобное, а только прямой доступ к памяти по адресам.

А также в отчете нужно описать, как работает операция ИСКЛЮЧАЮЩЕЕ ИЛИ и как поменять значения переменных местами, без привлечения третьей переменной, ну т.е.

Дано:

[source,c]
----
a = 3;
b = 4;
----

Чтобы не вводить 3 переменную.

Что бы не так:

[source,c]
----
c = a;
a = b;
b = c;
----
--
=== 1. Код программы
Откроем проект *Lab1* как в лабораторной работе №2, настроим проект, подключим плату и проверим, что всё работает. Для того, чтобы реализовать моргание всех 4 светодиодов необходимо подключить библиотеки портов A и C.

Код представлен ниже:

[source,c]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" //for Gpioa
#include "gpiocregisters.hpp" //for Gpioc
----

Для того, чтобы использовать прямой доступ по адресам необходимо воспользоваться *указателями* они образуются с помощью * и указывают на адрес переменной.

Запишем код для моргания всех 4 светодиодов:

[source,c]
----
int main()
{
    //Подать тактирование на порт А
    RCC::AHB1ENR::GPIOAEN::Enable::Set();
    //Подать тактирование на порт C
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    //Порта A. 5 на вывод
    GPIOA::MODER::MODER5::Output::Set();
    //Порта C.5, C.8, C.9 на вывод
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();

    //GPIOA::ODR::ODR5::High::Set();

    uint32_t* ptrPaOdr = reinterpret_cast<uint32_t*>(0x40020014);

    uint32_t* ptrPcOdr = reinterpret_cast<uint32_t*>(0x40020814);

    for(;;)
    {
        *ptrPaOdr ^= static_cast<uint32_t>(1 << 5);

        //1 << 5 = 000000b | 000010000b = 000010000b

        /*
        *ptrPaOdr |= static_cast<uint32_t>(1 << 5);
        *ptrPaOdr &=~ static_cast<uint32_t>(1 << 5);
        */

        *ptrPcOdr ^= static_cast<uint32_t>(1 << 5);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 9);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 8);


        delay(1000000);
        *ptrPaOdr ^= static_cast<uint32_t>(1 << 5);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 5);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 9);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 8);
        delay(1000000);
    }

    return 1;
}
----

Адрес *0x40020014*, который указан в строчке uint32_t* ptrPaOdr и строчке uint32_t* ptrPcOdr нужен для того, чтобы работать с линией *GPIOA* и *GPIOC*. Этот адрес можно получить следующим путем:

*1.* Нажать правой кнопокой мыши по слову *ODR* в строчке *GPIOA::ODR::ODR5::High::Set()* и выбрать из списка *Go to Definition of "ODR"* как показано на рисунке 1:

.Переход к адресу линии *GPIOA*
image::img1.jpg[]

*2.* Прочитать адрес выведенный снизу в окне программы для подлкюченных библиотек (рисунок 2).

.Окно *Ambiguous Definitions*
image::img2.png[]

В данном окне показаны два адреса на линии A и C. Они нам понадобятся для включения светодиодов через указатели.

Функция *delay* аналогична функции из лабораторной №3. Конструкция *reinterpret_cast* преобразует типы, несовместимыми друг с другом. К примеру в строчке uint32_t* ptrPaOdr = reinterpret_cast<uint32_t*>(0x40020014) данная конструкция преобразует адрес 0x40020014 в указатель типа uint32_t. В первой строчке цикла *for* мы сдвигаем *единицу* на 5 позиций влево, чтобы подключить пятый порт линии А с помощью операции *исключающее или*, которая обозначается ^. Затем мы также используя операцию *исключающее или* выключаем светодиод возвращая единицу обратно. В комментарии представлено такое же включение и выключение светодиода, но только уже с использованием операций *или* |, а затем *и не* & ~.

Также проделываем для линии C, но только чтобы включить порты C8 и C9 необходимо сдвигать 1 на 8 и 9 позиций влево.

Поставим точку остановки напротив первой строчки цикла *for* и запустим программу, а затем включим окно *Registers* (рисунок 3). Также выберем в строке *Group* линию *GPIOA* и отроем строчку *ODR*.

.Окно *Registers* с выключенным светодиодом *ODR5*
image::img3.png[]

Видим, что напротив *ODR5* стоит 0. Это означает, что светодиод не горит, на плате это видно. Нажмем *F10* и перейдем к следующей строке (рисунок 4).

.Окно *Registers* с включенным светодиодом *ODR5*
image::img4.png[]

На рисунке 4 показано, что напротив *ODR5* стоит 1 это означает, что светодиод горит, на плате это видно. Чтобы также увидеть то, что загораются светодиоды и на линии *GPIOC* нужно в поле *Group* выбрать *GPIOC*.

Уберем точку остановки и запустим программу, покажем действие на плате (рисунок 5).

.Реализация кода на плате
image::gif1.gif[]



=== 2. Описание операции исключающее ИЛИ
Оператор побитового исключающего или ( ^ ) сравнивает каждый бит своего первого операнда с соответствующим битом второго операнда. Если бит одного из операндов равен 0, а бит второго операнда равен 1, соответствующий бит результата устанавливается в значение 1. в противном случае — нулю. Приведем таблицу истинности (рисунок 6).

.Таблица истинности исключающего или
image::img6.png[]

Реазиловать обмен переменных местами можно следующим образом:

[source,c]
----
a ^= b ^= a ^= b;
----

Или так:

[source,c]
----
a = a ^ b;
b = b ^ a;
a = a ^ b;
----
