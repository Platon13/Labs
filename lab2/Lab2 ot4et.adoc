:imagesdir: Images
:figure-caption: Рисунок
:toc: Оглавление

= Лабораторная работа №1

== Задание 1
Написать программу вычисляющую следующее выражение -3/3U *3 ,удивиться увиденному и объяснить результат.

=== Создадим программу для вычисления

Создадим новую программу вычисляющую следующее выражение *-3/3U *3* (рисунок 1).

.Код программы
image::code.jpg[]

Полученный результат не является правильным математическим решением, но число -4 было получено не случайно.
Полученный результат связан с работой компилятора: U-указатель беззнакового числа, число -3 является знаковым.
При деление беззнакового числа на знаковое используется беззнаковая операция деления, а при умножении на 3 используется правильное знаковое умножение.Причина неправильного выполнения функции умножения скрыта в стандарте С++;
Причина неправильного выполнения функции умножения скрыта в стандарте С++;
****
Otherwise, if the unsigned operand's conversion rank is greater or equal to the conversion rank of" "the signed operand, the signed operand is converted to the unsigned operand's type.
****
Иначе, если ранг преобразования беззнакового операнда больше или равен рангу преобразования знакового операнда, то знаковый операнд приводится к типу беззнакового операнда.

Из-за этой операции деление выполняется не верно.

Тип int (знаковое) занимает в памяти 2 байта. Но в отличие от int, тип unsigned int может хранить только положительные целые числа в диапазоне от 0 до 65535. Так -3 = 11111111111111111111111111111101b.
Представим это 11111111111111111111111111111101 = 4294967293 в безнаковом десятичном виде.

Как выяснилилось ранее при делении знакового на беззнаковое, автоматом знаковое кастится к безнаковому. То есть -3 превращается в 4294967293 и делится на 3 = 1431655764,3333. Дробная часть числа будет откинута. После чего число снова будет умножено на три.

Конечный результат 4 294 967 292 = 11111111111111111111111111111100 А. Это в дополнительном коде -4

== Задание 2
Запустить на плате Lab1 из https://github.com/lamer0k/stm32Labs/tree/master/Lab1
добавить main код для зажигания светодиодов.

=== Запуск на плате Lab1

Скачав указанный репозиторий запустим файл мэйн. В файле мэйн обнаружим готовый код для платы.

.Код Lab1:
[source, cpp, linenums]

----
#include "rccregisters.hpp" // for RCC

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{
  //Switch on external 16 MHz oscillator
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {

  }

  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}


int main()
{


  return 0;
}
----

После подключим библиотеку;
[source, cpp, linenums]

----
#include "gpioaregisters.hpp" //for Gpioa
----

Подключив плату к компьютеру, выгрузим код на плату.

=== Зажигание светодиода

Для зажигания светодиода, добавим в мэйн код предоставленый преподователем

.Код для зажигания диода
[source, cpp, linenums]

----
 RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOA::ODR::ODR5::High::Set() ;
----
По схеме платы XNucleo-F411RE (рисунок 2) можно судить о назначении кода. А именно включение диода Led1 который соответствует пятому порту указоному в коде.

.Схема платы XNucleo-F411RE
image::scheme.png[]

При запуске кода ошибок не произошло. Выгрузив код в плату видим что всё сработало как и ожидалось

.Конечный вид программы
image::code2.jpg[]
.Плата с включённым диодом
image::diode.jpg[]

Выполнили:
Леонов В.А. КЭ-415
Платонов Д.В. КЭ-415





