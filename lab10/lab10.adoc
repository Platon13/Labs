:imagesdir: Images
:toc:
:toc-title: Оглавление

[.text-center]
МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ +
Федеральное государственное автономное образовательное учреждение высшего образования +
«Южно-Уральский государственный университет» +
(национальный исследовательский университет) +
Высшая школа электроники и компьютерных наук +
Кафедра «Информационно-измерительная техника»

[.text-center]

Отчет по лабораторной работе №10

[.text-right]
Выполнил: +
студент группы КЭ-415 +
Леонов В.А. +
Платонов Д.В.

:toc:
:toc-title: ОГЛАВЛЕНИЕ:

== Лабораторная работа №10
=== Задание
--
С помощью прерываний по интерфейсу USART передать фразу "Hello World!" в приложение Terminal. Также необходимо с помощью прерываний и таймеров TIM2 и TIM3 включать и выключать светодиоды для таймера TIM2 раз в полсекунды, а для таймера TIM3 раз в секунду.
--
=== 1. Включение светодиодов
Дадим определение прерывания.

image::img1.jpg[]

Для настройки таймера необходимо подключить библиотеки для регистров таймера и прерываний.

Библиотеки, которые необходимо подключить для таймера *TIM2* и *TIM3* приведены ниже.
[source,c]
----
#include "gpiocregisters.hpp" //for Gpioc
#include "gpioaregisters.hpp" //for Gpioa
#include "rccregisters.hpp"   //for RCC
#include "tim2registers.hpp"   //for SPI2
#include "nvicregisters.hpp"  //for NVIC
#include "tim3registers.hpp"
#include "usart2registers.hpp" // for USART2
#include <string>
#include "MessageTransmitter.h"
----
Также нужно настроить плату на внешний тактовый генератор (8 МГц) и подать тактирование на *GPIOC* и настроить необходимые порты (8-ой и 5-ый) на выход. Листинг кода приведен ниже.

[source,c]
----
int __low_level_init(void)
{
    //Switch on external 16 MHz oscillator
    RCC::CR::HSEON::On::Set() ;
    while (!RCC::CR::HSERDY::Ready::IsSet())
    {
    }
    //Switch system clock on external oscillator
    RCC::CFGR::SW::Hse::Set() ;
    while (!RCC::CFGR::SWS::Hsi::IsSet())
    {
    }
    
    RCC::AHB1ENR::GPIOCEN::Enable::Set(); //подали тактирование на GPIOC
    GPIOC::MODER::MODER8::Output::Set();  //настроили порт PORTC.8 на выход
    GPIOC::MODER::MODER5::Output::Set();  //настроили порт PORTC.5 на выход
----

==== 2 Прерывание по таймеру TIM2

Настроим таймер *TIM2*.

Согласно регистру *RCC* переключение на частоты таймера *TIM2* происходит в 0 бите (рисунок 1).

.Регистр *RCC_APB1ENR*
image::img1.png[]

Далее записываем в регистр *TIM2_PSC* значение тактовой частоты счетчика с помощью переменной *TimerPrescaler*, которая была определена раньше.

.Регистр *TIMx_PSC*
image::img2.png[]

Листинг кода определения тактовой частоты.
[source,c]
----
constexpr auto SystemClock = 8'000'000U;
constexpr auto TimerClock = 1'000U;
constexpr auto TimerPrescaler = SystemClock / TimerClock;
----

Настройка прерывания происходит в регистре *NVIC_INSER0* (для таймера *TIM2* и *TIM3* ). Таймер *TIM2* стоит на позиции 28, а  *TIM3* на 29.(рисунок 3).

.Таблица векторов прерывания
image::img3.jpg[]

Затем необходимо включить прерывание с помощью регистра *TIMx_DIER* и выбрать *UIE* (рисунок 4).

.Регистр *TIMx_DIER*
image::img4.jpg[]

Прерывание по UIE Update interrupt enable представлен на рисунке 5.

image::img5.jpg[]

В конце включим таймер *TIM2* с помощью регистра *TIMx_CR1* и выберем *CEN* рисунок 6.

.Регистр *TIMx_CR1*
image::img6.jpg[]

Листинг кода настройки таймера *TIM2* приведен ниже.
[source,c]
----
Настройка таймера 2

    RCC::APB1ENR::TIM2EN::Enable::Set();
    TIM2::PSC::Write(TimerPrescaler);
    TIM2::ARR::Write(1000);
    TIM2::CNT::Write(0);
    
    NVIC::ISER0::Write(1 << 28U);
    TIM2::DIER::UIE::Enable::Set();
    TIM2::CR1::CEN::Enable::Set();


//Настройка прерывания
    NVIC::ISER0::Write(1 << 28U);
    TIM2::DIER::UIE::Enable::Set();
    TIM2::CR1::CEN::Enable::Set();
----

Настройка функции прерывания происходит в файле *interrupthandler.hpp*. Опишем функцию для таймера *TIM2* в данном файле. В данном файле используется регистр статуса *TIMx_SR* бит 0 (*UIF*), который проверяет *flag* запуска прерывания и если он активен, то выключает прерывание и включается светодиод.

.Регистр *TIMx_SR*
image::img6.jpg[]

Листинг кода файла *interrupthandler.hpp* приведен ниже.

[source,c]
----
#ifndef REGISTERS_INTERRUPTHANDLER_HPP
#define REGISTERS_INTERRUPTHANDLER_HPP


#include "tim2registers.hpp"  //for TIM2
#include "gpiocregisters.hpp"  //for GPIOC
#include "messagetransmitter.h" // for MessageTransmitter

class InterruptHandler {
  public:
    static void DummyHandler() { for(;;) {} }
    static void Timer2Handler()
    {
      //
      if (TIM2::SR::UIF::UpdatePending::IsSet())
      {
        TIM2::SR::UIF::NoUpdate::Set();
        GPIOC::ODR::Toggle(1 << 8) ;
      }
    }
};

#endif //REGISTERS_INTERRUPTHANDLER_HPP
----

Чтобы прерывание работало необходимо задать использование данной функции в файле *startup.cpp*, в котором после закомментрированной строчки *//External Interrupts* отсчитать 28 позиций, как раз на которой должен находится *TIM2* (рисунок 3) согласно таблице прерываний. И записать туда функцию данную. Листинг кода данного файла приведен ниже.
[source,c]
----
#include "interrupthandler.hpp"  //for InterruptHandler

extern "C" void __iar_program_start(void) ;

using tIntFunct = void(*)();
using tIntVectItem = union {tIntFunct __fun; void * __ptr;};
#pragma segment = "CSTACK"
#pragma location = ".intvec"
const tIntVectItem __vector_table[] =
{
  { .__ptr = __sfe( "CSTACK" ) }, //????????????? ????????? ?? ????
    __iar_program_start, //????? ??????? ????? ????? ? ?????????

  InterruptHandler::DummyHandler,
  InterruptHandler::DummyHandler,
  InterruptHandler::DummyHandler,
  InterruptHandler::DummyHandler,
  InterruptHandler::DummyHandler,
  0,
  0,
  0,
  0,
  InterruptHandler::DummyHandler,
  InterruptHandler::DummyHandler,
  0,
  InterruptHandler::DummyHandler,
  InterruptHandler::DummyHandler,
  //External Interrupts
  InterruptHandler::DummyHandler,         //Window Watchdog
  InterruptHandler::DummyHandler,         //PVD through EXTI Line detect/EXTI16
  InterruptHandler::DummyHandler,   //Tamper and Time Stamp/EXTI21 
  InterruptHandler::DummyHandler,         //RTC Wakeup/EXTI22 
  InterruptHandler::DummyHandler,             //FLASH
  InterruptHandler::DummyHandler,               //RCC
  InterruptHandler::DummyHandler,         //EXTI Line 0
  InterruptHandler::DummyHandler,         //EXTI Line 1
  InterruptHandler::DummyHandler,         //EXTI Line 2
  InterruptHandler::DummyHandler,        //EXTI Line 3
  InterruptHandler::DummyHandler,         //EXTI Line 4
  InterruptHandler::DummyHandler,       //DMA1 Stream 0
  InterruptHandler::DummyHandler,       //DMA1 Stream 1
  InterruptHandler::DummyHandler,       //DMA1 Stream 2
  InterruptHandler::DummyHandler,       //DMA1 Stream 3
  InterruptHandler::DummyHandler,       //DMA1 Stream 4
  InterruptHandler::DummyHandler,      //DMA1 Stream 5
  InterruptHandler::DummyHandler,      //DMA1 Stream 6
  InterruptHandler::DummyHandler,              //ADC1
  0,   //USB High Priority
  0,    //USB Low  Priority
  0,               //DAC
  0,              //COMP through EXTI Line
  InterruptHandler::DummyHandler,         //EXTI Line 9..5
  InterruptHandler::DummyHandler,              //TIM9/TIM1 Break interrupt 
  InterruptHandler::DummyHandler,             //TIM10/TIM1 Update interrupt
  InterruptHandler::DummyHandler,             //TIM11/TIM1 Trigger/Commutation interrupts
  InterruptHandler::DummyHandler,			   //TIM1 Capture Compare interrupt
  InterruptHandler::Timer2Handler,         //TIM2  28	
  InterruptHandler::DummyHandler,         //TIM3   29
  InterruptHandler::DummyHandler,        ////TIM4 30
  InterruptHandler::DummyHandler,       //31
  InterruptHandler::DummyHandler,       //32
  InterruptHandler::DummyHandler,       //33
  InterruptHandler::DummyHandler,       //34
  InterruptHandler::DummyHandler,       //35
  InterruptHandler::DummyHandler,       //36
  InterruptHandler::DummyHandler,       //37
  InterruptHandler::Usart2Handler       //USART2 38
};

extern "C" void __cmain(void) ;
extern "C" __weak void __iar_init_core(void) ;
extern "C" __weak void __iar_init_vfp(void) ;

#pragma required = __vector_table
void __iar_program_start(void) {
  __iar_init_core() ;
  __iar_init_vfp() ;
  __cmain() ;
}

----

==== 2. Прерывание по таймеру TIM3

Настройка таймера производится точно также, за исключением того, что нужно подключить другую библиотеку, также согласно таблице прерываний *TIM3* находится на позиции 29, то есть на эту позицию необходимо вставить функцию прерывания по таймеру *TIM3* и также нужно будет поменять время с 1000 мс на 500 мс, чтобы согласно заданию всё работало.

Листинг настройки таймера *TIM3* приведен ниже.
[source,c]
----
//Настройка таймера 3
    RCC::APB1ENR::TIM3EN::Enable::Set();
    TIM3::PSC::Write(TimerPrescaler);
    TIM3::ARR::Write(500);
    TIM3::CNT::Write(0);
    
    NVIC::ISER0::Write(1 << 29U);
    TIM3::DIER::UIE::Enable::Set( );
    TIM3::CR1::CEN::Enable::Set( );
----

Листинг функции прерывания для таймера *TIM3* приведен ниже.
[source,c]
----
static void Timer3Handler()
    {
      if (TIM3::SR::UIF::UpdatePending::IsSet())
      {
        TIM3::SR::UIF::NoUpdate::Set();
        GPIOC::ODR::Toggle(1 << 5) ;
      }
    }
----

=== 3. Передача словосочетания Hello World по интерфейсу USART
Для начала опишем всю структуру в программе *StarUML*.

.Структура программы передачи словосочетания Hello World по USART
image::img8.jpg[]

В данной структуре имеются функции *Send(message: string&)* и *OnByteTransmitte()*, первая принимает сообщение и передает каждый бит в массив *buffer* и затем записывает этот *buffer* в передачу интерфейса *USART* и разрешает передачу. Вторая же функция также передает в передачу интерфейса символы, пока количество их не станет равным количеству символов введенной переменной. Иначе запрещает передачу по интерфейсу *USART*. Переменная *isMessageTransmit* (используется в качестве флага) отвечает за полную передачу слова по интерфейсу *USART*, если бы ее не было, то передавась бы только 1 буква *H*. Две переменные *byteCounter* и *messageLenght* отвечают за: 1-ая - счетчик символов слова, 2-ая - длину сообщения (слова).

Осталось всё описать программно. Создаем папку *MessageTransmitter* и два файла *Messagetransmitter.h* и *Messagetransmitter.cpp*. Не забываем подключить путь к данным файлам в опциях проекта. В первом файле опишем все переменные и функции, которые используются в программе, а во втором опишем функции.

Листинг кода файла *messagetransmitter.cpp* представлен ниже:
[source,c]
----
#include "MessageTransmitter.h"
#include "usart2registers.hpp"  // for USART2

void MessageTransmitter::Send(const std::string& message)
{
  if(isMessageTransmit)
  {
   isMessageTransmit = false;
      //Copy string to buffer
  std::copy_n(message.begin(), message.size(), buffer.begin());
  byteCounter = 0;
  messageLength =  message.size();
  USART2::DR::Write(buffer[0]byteCounter]);
  USART2::CR1::TE::Enable::Set(); // razreshaem peredachy
  USART2::CR1::TXEIE::Enable::Set(); // razreshaem prerivanie
  byteCounter++;
  }

}

void MessageTransmitter::OnByteTransmit()
{
  if(byteCounter <= messageLength)
  {
    USART2::DR::Write(buffer [byteCounter]);
    byteCounter++;
  }
  
  else
  {
    isMessageTransmit = true;
    USART2::CR1::TE::Disable::Set(); // zapret peredachy
    USART2::CR1::TXEIE::Disable::Set(); // zapret prerivanie
  }
}
----

Листинг кода файла *Messagetransmitter.h* представлен ниже:
[source,c]
----
#pragma once
#include <string> // for std::string
#include <array>

class MessageTransmitter
{
public:
  static void Send (std::string& message);
  static void OnByteTrasmit();
  
private:
  bool isMessageTransmit = true;
  inline static std::array<uint8_t, 255> buffer = { };
  inline static size_t byteCounter = 0U;
  inline static size_t messageLength = 0U;
};
----

Затем необходимо описать библиотеку для *USART* в файле *main.cpp*.
[source,c]
----
#include "gpiocregisters.hpp" //for Gpioc
#include "gpioaregisters.hpp" //for Gpioa
#include "rccregisters.hpp"   //for RCC
#include "tim2registers.hpp"   //for SPI2
#include "nvicregisters.hpp"  //for NVIC
#include "tim3registers.hpp"
#include "usart2registers.hpp" // for USART2
#include <string>
#include "MessageTransmitter.h"
----

Также в файле *main.c* необходимо настроить интерфейс *USART*. Согласно таблице прерываний интерфейс *USART2* находится на позиции 38, то тут уже используется регистр *NVIC_ISER1*. Вся остальная настройка производится также как и в прошлой лабораторной работе №9.

Листинг настройки *USART2* приведен ниже.
[source,c]
----
Настройка USART2

//port A k sisteme tactirovaniy

    RCC::AHB1ENR::GPIOAEN::Enable::Set();    
    
//port A2 i A3 na alternativn rezhim raboty

    GPIOA::MODER::MODER2::Alternate::Set();
    GPIOA::MODER::MODER3::Alternate::Set();

//port A2 i A3 na alternativn fynkciu
    
    GPIOA::AFRL::AFRL2::Af7::Set();  // USART2 Tx
    GPIOA::AFRL::AFRL3::Af7::Set();  // USART2 Rx    
    
// podklychenie USART2 k sisteme taktirovania APB1
    RCC::APB1ENR::USART2EN::Enable::Set();

    USART2::CR1::OVER8::OversamplingBy16::Set();
    USART2::CR1::M::Data8bits::Set();
    USART2::CR1::PCE::ParityControlDisable::Set();
    
    USART2::BRR::Write(8'000'000 / 9600); // 8 MHz
    
    NVIC::ISER1::Write(1 << 6U);
    
  return 1;
}
----

Осталось в функции *main* описать работу программы.

Листинг кода функции *main* предасавлен ниже.
[source,c]
----
int main(void)
{
  std::string TestMessage = "Hello world! ";

  for(;;)
  {
    MessageTransmitter::Send(TestMessage);
  }
}
----

Представим работу светодиодов и интерфейса *USART* (рисунок 9 и 10).

.Результат работы светодиодов
image::gif1.gif[]

.Вывод результата в программе *Terminal v1.9*
image::img9.png[]
