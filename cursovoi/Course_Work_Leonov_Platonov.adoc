:imagesdir: Images
:toc:
:toc-title: Оглавление

[.text-center]
МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ +
Федеральное государственное автономное образовательное учреждение высшего образования +
«Южно-Уральский государственный университет» +
(национальный исследовательский университет) +
Высшая школа электроники и компьютерных наук +
Кафедра «Информационно-измерительная техника»

[.text-center]

Отчет по курсовой работе

[.text-right]
Выполнили: +
студенты группы КЭ-415 +
Леонов В.А. +
Платонов Д.В.


== Задание на курсовую работу

image::Kursovoy_variant_11_page-0001.jpg[]

image::Kursovoy_variant_11_page-0002.jpg[]

image::Kursovoy_variant_11_page-0003.jpg[]

image::Kursovoy_variant_11_page-0004.jpg[]

== Отладочная плата XNUCLEO-F411RE
Отладочная плата на базе микроконтроллера STM32F411RE, представляет собой гибкую платформу, позволяющую расширять свои функциональные возможности с помощью плат расширения для Arduino и ST Morpho. Плата XNUCLLEO-F411RE изображена на рисунке 1.

image::image.png[]

Рисунок 1 - Отладочная плата XNUCLEO-F411RE

== Плата расширения Accessory Shield

Accessory Shield — это плата расширения, совместимая с популярными платформами для разработки электронных приложений, такими как Arduino UNO, Arduino Leonardo, NUCLEO, XNUCLEO и совместимыми. На плате установлены самые популярные дочерние модули, подходящие для реализации большинства задач. Плата расширения Accessory Shield представлена на рисунке 2.

image::Плата расширения.jpg[]

Рисунок 2 - Плата расширения Accessory Shield

== Переменный резистор

Переменные резисторы — это разновидность резисторов, электрическое сопротивление которых регулируется с помощью механического воздействия на регулировочный орган.
Переменный резистор находится на плате расширения Accessory Shield с номиналом 10 кОм и подключается к каналу А0. Переменный резистор представлен на рисунках 3 и 4.

image::Резистор.jpg[]

Рисунок 3 - Переменный резистор

image::Резистор на схеме.jpg[]

Рисунок 4 - Переменный резистор

== Операционные Системы реального Времени

Дадим определение понятию "Операционные системы реального времени" или "Real Time Operating Systems".

Операционные системы реального времени (ОСРВ(RTOS)) предназначены для обеспечения интерфейса к ресурсам критических по времени систем реального времени. Основной задачей в таких системах является своевременность (timeliness) выполнения обработки данных". Задачей ОСРВ является обеспечение реакции на определенное действие за отведенный квант времени. Для разных задач такой квант может иметь разное значение, например, для обработки. Приблизительное время реакции в зависимости от области применения ОСРВ может быть следующее: Математическое моделирование - несколько микросекунд.

Радиолокация - несколько миллисекунд.

Складской учет - несколько секунд.

Управление производством - несколько минут.

image::image-2022-02-23-14-26-15-766.png[]

Рисунок 5 - Операционные Системы Реального Времени

== Архитектура классов

Архитектура классов представлена на рисунке 5.

image::Архитектура.jpg[]

Рисунок 4 - Архитектура классов в StarUML

== Описание классов

=== Класс main.cpp

В данном классе производится настройка всех задействованных портов, а также производится запуск задач.

Первым шагом является подача тактирования на нужные порты.

image::Курсовая_1.jpg[]

image::Курсовая_2.jpg[]

image::Курсовая_3.jpg[]

image::Курсовая_4.jpg[]

Далее нужно настроить порт A0 в аналоговый режим, а порты C6, C7, C8, C9 настроить в альтернативный режим.

image::Курсовая_8.jpg[]

Примечание: при работе с платой были использованы перемычки, чтобы использовать только третий таймер для всех четырех светодиодов.

image::Схема_1.jpg[]

image::Схема_2.jpg[]

image::Курсовая_6.jpeg[]

image::Курсовая_7.jpeg[]

Далее нужно назначить каналы таймеров. Данная настройка производится с помощью реигстров AFRL (для портов с номером от 0 до 7) и AFRH (для портов с номером от 8 до 15).

image::Курсовая_9.jpg[]

image::Курсовая_10.jpg[]

Далее нужно настроить ШИМ. Для этого сначала устанавливается захват на 4 канала.

image::Курсовая_11.jpg[]

image::Курсовая_12.jpg[]

image::Курсовая_13.jpg[]

image::Курсовая_14.jpg[]

После этого включается ШИМ, а также предварительная загрузка.

image::Курсовая_16_новая.jpg[]

image::Курсовая_17_новая.jpg[]

image::Курсовая_18_новая.jpg[]

image::Курсовая_19_новая.jpg[]

image::Курсовая_20.jpg[]

image::Курсовая_21.jpg[]

image::Курсовая_22.jpg[]

image::Курсовая_23.jpg[]

Далее запускаем третий таймер.

image::Курсовая_24.jpg[]

image::Курсовая_25.jpg[]

image::Курсовая_26.jpg[]

=== Класс Message

image::image-2022-05-06-16-17-27-738.png[]

Класс Message используется для передачи сообщения. В нем содержатся переменная, содержащая в себе значение напряжения, а также само передаваемое сообщение.

Фрагмент кода представлен ниже.

[source, c]
 void Execute() // Метод, отвечающий за передачу значений
  {
    for(;;)
    {
   out = myMainTask.GetVolt(); // Переменная, которая содержит значение напряжения
   sprintf(mes, "Voltage = %1.4f V \n", out); // Информация, которая передается в терминал
   usartDriver.SendMessage(mes, strlen(mes)); // Отправка сообщения
   Sleep(333ms); // Заснуть на 100 мс
    }
  }

=== Класс Led

image::image-2022-05-06-16-17-55-237.png[]

Класс Led используется для описания методов расчета яркости светодиодов, а также содержит в себе метод регулировки яркости, который передается в класс PWM.hpp.

Фрагмент кода представлен ниже.

[source, c]
  void CalculateDutyCycle(uint16_t Value) // Метод для расчета яркости
  {
    if (Value >= 0.2F)
    {
      DutyCycle = static_cast<uint16_t>(k*static_cast<float>(Value) + b); // Рассчитанная яркость
    }
    else
      DutyCycle = 0; // Светодиод не горит
  }
  void SetDutyCycle() // Метод для передачи рассчитанного значения
  {
    pwm.SetDuty(DutyCycle); // Передать значение яркости в класс PWM
  }

=== Класс LedTask

image::image-2022-05-06-16-18-20-276.png[]

Класс LedTask используется для передачи рассчитанных значений DutyCycle в класс Led.hpp.

Фрагмент кода представлен ниже.

[source, c]
  for(;;)
    {
    Value = MainTask.GetVolt(); // Получаем значение напряжения и записываем его в переменную Value
    Sleep(100ms); // Задержка 100 мс для ОСРВ
    led.CalculateDutyCycle(Value); // Передаем значение напряжения в метод CalculateDutyCycle
    led.SetDutyCycle(); // Передача значения
    }

=== Класс MainTask

image::image-2022-05-06-16-18-55-860.png[]

Класс MainTask используется для запуска измерений, а также расчета значений напряжения и их фильтрации.

Фрагмент кода представлен ниже.

[source, c]
 void Execute() override
  {
    myAnalog::adcConfig(Resolution::Bits12, tSampleRate::Cycles480); // Настраиваем АЦП
    myAnalog::SetChannels(18); // Подключаем каналы
    myAnalog::dmaConfig(); // Подключаем DMA
    myAnalog::On(); // Включаем АЦП
    myAnalog::Start(); // Начало измерений
   for(;;)
  {
    auto codes = myAnalog::GetValue(); // Записываем значения напряжения в переменную codes
    VoltageValue.Calculation(codes[0]); // Рассчитываем значение
    VoltageValue.GetValueAndName();
    auto var = filter.Update(VoltageValue.GetValue()); // Записываем в переменную var значение напряжения с использованием фильтра
    std::cout<<var<<std::endl;
    Sleep(50ms); // Заснуть на 50 мс
  }
  }

=== Класс Analog

image::image-2022-05-06-16-19-36-451.png[]

Класс Analog используется для настройки АЦП. Содержит в себе настройки таких параметров, как Resolution, SampleRate, а также запускает сам АЦП и содержит метод для настройки DMA.

Фрагмент кода представлен ниже.

[source, c]
enum class Resolution // Классы enum используются для перечисления. Конкретно здесь - количество битов
{
  Bits12,
  Bits10,
  Bits8,
  Bits6
};
enum class tSampleRate // Колисчество циклов
{
  Cycles3,
  Cycles15,
  Cycles28,
  Cycles56,
  Cycles84,
  Cycles112,
  Cycles144,
  Cycles480
};

=== Класс DMA

image::image-2022-05-06-16-19-58-714.png[]

Класс DMA используется для настройки DMA. Содержит в себе настройки таких параметров, как ChannelSet, DirectionSet, DataSizeSet, TargetSet.

Фрагмент кода представлен ниже.

[source, c]
  static void ChannelSet()
  {
    D::S0CR::CHSEL::Value0::Set();
  }
  static void DirectionSet() // Установка направления
  {
    D::S0CR::DIR::Value0::Set();
  }

=== Класс Variable

image::image-2022-05-06-16-20-14-916.png[]

Класс Variable используется для описания переменных, применяемых в других классах.

Фрагмент кода представлен ниже.

[source, c]
public:
  Variable(float k1, float b1): k(k1), b(b1) {}; // Передаем значения коэффициентов k и b
  virtual void Calculation(std::uint32_t code) = 0; // Рассчитываем значения напряжения
  virtual float GetValue() = 0;
  virtual void GetValueAndName() = 0;

=== Класс Voltage

image::image-2022-05-06-16-20-46-244.png[]

Класс Voltage используется для получения рассчитанных значений напряжения.

Фрагмент кода представлен ниже.

[source, c]
void Calculation(std::uint32_t code) override // Описание метода из класса Variable
  {
    Value = k*code + b;
  }
   float GetValue() override
  {
    return Value;
  }
  void GetValueAndName() override
  {}

=== Класс PWM

image::image-2022-05-06-16-20-54-284.png[]

Класс PWM используется для регулировки яркости светодиодов с помощью ШИМ. Регулировка яркости происходит в зависимости от напряжения. Регулировка происходит с помощью условий if.

Фрагмент кода представлен ниже.

[source, c]
public:
  void SetDuty(uint16_t DutyCycle) // Создаем метод и передаем в него значение, рассчитанное в другом классе
  {

   if (DutyCycle < 16390)
  {
    Timer::CCR1::Write(DutyCycle); // Регулируется яркость первого светодиода
     Timer::CCR2::Write(0); // Четвертый светодиод не горит
        Timer::CCR3::Write(0); // Третий светодиод не горит
          Timer::CCR4::Write(0); // Второй светодиод не горит
  }
else  {
 Timer::CCR1::Write(16390); // Первый свтодиод горит на максимальной яркости
     Timer::CCR2::Write(0); // Четвертый светодиод не горит
        Timer::CCR3::Write(0); // Третий светодиод не горит
          Timer::CCR4::Write(0); // Второй светодиод не горит

=== Класс Transmit

image::image-2022-05-06-16-21-11-723.png[]

Класс Transmit используется для побитовой предачи сообщения.

Фрагмент кода представлен ниже.

[source, c]
public:
  virtual void OnNextByteTransmit() = 0; // Доступ класса USART к методу OnNextByteTransmit() класса USARTDriver

=== Класс USART

image::image-2022-05-06-16-21-24-749.png[]

Класс USART используется для настройки USART.

Фрагмент кода представлен ниже.

[source, c]
 public:
  Usart(Transmit& aTransmit): transmit(aTransmit) // Хранит ссылку на объект класса Transmit
    {
    }
   static void WriteByte(std::uint8_t byte) // Запись данных в регистр
  {
    TUSARTReg::DR::Write(byte);
  }

=== Класс USARTDriver

image::image-2022-05-06-16-21-33-071.png[]

Класс USARTDriver используется для отправки сообщения.

Фрагмент кода представлен ниже.

[source, c]
public:
   void OnNextByteTransmit() // Отвечает за побайтовую передачу сообщения
  {
    TUsart::WriteByte(TransmitBuffer[i++]);
    if (i >= size)
    {
      TUsart::TransmitDisable();
      TUsart::InterruptDisable();
      i = 0U;
    }
  }
   void SendMessage(const char* message, size_t aSize) // Отвечает за отправку сообщения по USART
  {
    assert(size <= 255);
    memcpy(TransmitBuffer.data(), message, aSize);
    size = aSize;
    i = 0U;
    TUsart::WriteByte(TransmitBuffer[i++]);
    TUsart::TransmitEnable();
    TUsart::InterruptEnable();
  }

=== Класс Filter

image::image-2022-05-06-16-22-13-748.png[]

Класс Filter используется для фильтрации полученных значений напряжения.

Фрагмент кода представлен ниже.

[source, c]
private:
  float OldValue = 0.0f; // Объявляем переменную
  static constexpr float dt = 100.0f;
  static constexpr float RC = 100.0f;
  inline static const float tau = 1.0f - exp(-dt/RC);
  public:
  float Update(float Value) // Создаем класс и передаем в него значение напряжения
  {
    float FilteredValue = OldValue + (Value - OldValue)*tau; // Формула для фильтрации
    OldValue = FilteredValue;
    return FilteredValue;
  }
  float GetOldValue (float Value)
  {
    float FilteredValue = OldValue + (Value - OldValue)*tau;
    OldValue = FilteredValue;
    return FilteredValue;
  }

== Подключение платы к компьютеру
Подключим отладчик к плате, и подключим плату к компьютеру. Результат представлен на рисунке 6.

image::plata1.jpg[]

Рисунок 6 - Подключенная плата

Светодиод на отладчике горит красным, что говорит нам о том, что плата не прошита.

== Прошивка платы

Успешно прошиваем плату. Можем убедиться в этом, увидев светодиоды, которые регулируют свою яркость в зависимости от изменяемого напряжения.
Результат представлен на рисунке 7.



Рисунок 7 - Прошитая плата

Скриншот из Terminal представлен на рисунке 8.



Рисунок 8 - Скриншот из Terminal
