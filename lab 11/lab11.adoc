:imagesdir: images
:toc:
:toc-title: Оглавление

[.text-center]
МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ +
Федеральное государственное автономное образовательное учреждение высшего образования +
«Южно-Уральский государственный университет» +
(национальный исследовательский университет) +
Высшая школа электроники и компьютерных наук +
Кафедра «Информационно-измерительная техника»

[.text-center]

Отчет по лабораторной работе №11

[.text-right]
Выполнил: +
студент группы КЭ-415 +
Леонов В.А. +
Платонов Д.В.

:toc:
:toc-title: ОГЛАВЛЕНИЕ:

== Лабораторная работа №11
=== Задание
--
Написать программу, которая позволяет моргать светодиодами, с использованием операционных систем реального времени.
--
=== 1. Операционные системы реального времени (OCPB(RTOS))
Данные системы предназначены для обеспечения интерфейса к ресурсам критических по времени систем реального времени. +
Оснвной задачей в таких ситемах является своевременность (timeliness) выполнения обработки данных. +
Задачей OCPB является обеспечение реакции на определенное действие за отведенный квант времени. +
Для разных задач такой квант может иметь разное значение, например, для обработки. Приблизительное время реакции в зависимости от области применения OCPB может быть следующее: +
математическое моделирование - несколько микросекунд; +
радиолокация - несколько милисекунд; +
складской учет - несколько секунд; +
управление производством - несколько минут. +
Принцип работы и запуска задачи похож на принцип работы прерыванния представлен на рисунке 1. +

image::1.jpg[]
Рисунок 1 +

В ОСРВ вместо прерывний используется задачи, которые вызываются планировщиком каждый раз по прерыванию симного таймера (например в 1 мс) или при непосредственном вызове планировщика.
Каждый раз планировщик пробегается по списку задач и выбирает задачу готовую к работе (рисунок 2).

image::2.jpg[]
Рисунок 2 +

В кооперативной многозадачности планировщик смотрит, завершена ли текущая задача и готова ли следующая (с большим приоритетом). +
В вытесняющей планировщик смотрит, готова ли более высокоприоритеная задача, если да, он прерывает работе менее приоритетной залачи и вызывает задачу с большим приоритетом. +
Планировщик озаботится тем, чтобы у каждой задачи все сохранялось и запоминалось: текущее положение, стек, переменные, регистры.

=== 2. Структура программы в StarUML

Для того что бы написать программу, стоит построить ее структуру в программе StarUML. Ее можно увидеть на рисунке 3.

image::3.jpg[]
Рисунок 3 +

===3. Написание кода
Создали класс MyFirstTask, который наследует класс Thread. У класса Thread есть метод Execute. Переопределили виртуальный метод Execute.
Программа "myfirsttask.h" представлена ниже.

[source, c]
#pragma once
#include "thread.hpp" // for Thread

class MyFirstTask : public OsWrapper:: Thread<200>
{
public:
  void Execute() override;
};

в программе "myfirsttask.cpp" описали метод Execute. 
[source, c]
#include "myfirsttask.h"
#include "gpiocregisters.hpp" // for GPIOC

void MyFirstTask::Execute()
{
  for(;;)
  {
    GPIOC::ODR::Toggle(1 << 8);
    Sleep(1000ms);
  }
}

